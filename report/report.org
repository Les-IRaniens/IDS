#+LaTeX_CLASS_OPTIONS: [a4paper]
#+Latex_CLASS: report
#+LaTex_HEADER: \usepackage[francais]{babel}
#+LaTex_HEADER: \usepackage{graphicx}

#+BEGIN_LaTex
\begin{titlepage}
\centering
  {\scshape Hénallux\par\vspace{0.2cm} Section sécurité des systèmes\par \vspace{0.2cm}}
  \vspace{1cm}
  \includegraphics[width=0.5\textwidth]{img/school}\par\vspace{1cm}
  {\scshape \LARGE Développement \par}
  \vspace{0.2cm}
	{\scshape \Large Implémentation d'un IDS\par}
  \vspace{3cm}
  {\Large\itshape Projet réalisé par \par\vspace{0.5cm} Mustafa-Can KUS \par Jordan DALCQ \par}
  \vfill
  \scshape Année académique 2020-2021 
  \title{Implémentation d'un IDS}
  \author{Mustafa-Can KUS Jordan DALCQ}
  \date{2020-2021}
\end{titlepage}

\pagestyle{headings}
#+END_LaTex
#+LaTex: \tableofcontents

* Introduction
** Contexte
Dans le cadre du cours de développement il nous a été demandé de réalisé un système de détection d'intrusion (ou IDS pour faire plus cours).
Ce programme à pour but d'analyser le trafique réseau et reporter toutes activité suspectes à un administrateur système ou même un administrateur réseau
grâce à un système de log.

** Outils utilisés
*** Org mode
Org mode est un mode majeur pour le logiciel GNU Emacs qui permet de prendre notes et maintenir une Todo liste et permet aussi de planifier facilement des projets
grâce à son langage Markup (très proche du markdown). On l'a utilisé pour écrire ce report (ok on a un peu tricher on a mit un peu de Latex pour faire joli) et aussi
pour planifier notre travail 

#+NAME: fig:org-mode
#+CAPTION: Capture d'écran de notre rapport écrit avec l'Org mode
#+ATTR\_ORG: width 120
[[./img/org.png]]
*** Github
Une fois notre planing fait il nous fallait une solution pour que chaqu'un d'entre nous aie une copie du code toujours à jours 
et qu'on puisse tracker nos modifications, ce qui est très pratique en cas de bug, en effet il nous aurait suffit que de revenir 
quelques modifications en arrière et le problème est régler !

Notre projet est disponible ici:
#+BEGIN_LaTex
\begin{center}
    {\small \url{https://github.com/Les-IRaniens/IDS}}
\end{center}
#+END_LaTex
*** GNU Makefile
Comme tous bon informaticiens qui se respecte, on a pas envie de tapper une très longue commande composé d'une dixène de fichiers et d'une
autres dixène de flag à chaque fois qu'on souhaite compiler notre programme, alors on a décider d'utiliser un makefile. 
Le makefile s'occupe de compiler et de linker notre code automatiquement, il suffit de tapper make dans le terminal et le tour est jouer !
*** Nos flags de compilations
- -pednatic: nous oblige fortement à adhérer aux règles de l'ANSI C
- -Wpednatic: nous affiche des warnings si on respecte pas la pedantic
- -Wall: nous permet d'avoir tous les warnings sur des pratiques considérées comme questionnable
- -Wextra: Couvre encore plus de warnings que -Wall
- -Werror: Transforme tous les warnings en erreur (Oui on est sans pitier ici)
- -g: Permet d'avoir les symboles de debugger
- -Isrc/: Permet d'inclure facilement les headers du dossier src
- -fsanitize=undefined & -fsanitize=undefined: Permet de tracker chaque memory leaks et nous dit sur quelle ligne est le problème
- -lpcap: Inclus la libpcap à notre projet

*** ArchLinux
Programmer sur Kali c'est pas top, surtout sur une VM ! Donc on a préférer utiliser ArchLinux pour le travail sur machine native.
Pourquoi celà ? Car Archlinux est une distribution polyvalante qui a TOUS les paquets qu'on désire (oui même tous les paquets de Kali)
*** Vscodium
C'est Visual Studio Code - les fonctions de télémétries, c'est notre éditeur de choix, car il permet une super bonne intégration avec notre github,
nous informe de nos erreurs et des warnings potentiels grâce à l'extension C/C++.
* Explications du code
Dés le départ nous avons penser à subdiviser le code en plusieurs fichier, celà permet de limiter le nombre de ligne de code
par fichier, en effet le maximum par fichier est de 300 lignes de code, se qui permet de trouver nos erreurs plus efficacement

** main.c
*** int main (int argc, char *argv[])
C'est un peux le chef d'orchestre de notre programme, ce fichier contient la fonction main qui donne les entrées utilisateurs au différentes fonctions grâce
aux paramètres donné au programme (argv) et vérifie que l'utilisateur démarre bien le programme avec \sudo\.

** usage.c
*** void show_usage (char *exe_path)
Si l'utilisateur nous donne aucun paramètre ou si il nous donne le paramètre d'aide (-h | --help)
la fonction main nous envois sur cette fonction et nous montre un message d'utilisation. L'argument exe\_path comprend le chemain de l'executable
et on récupère que le nom de l'executable (grâce à la fonction basename)

** checkuser.c
*** bool is_root(void)
il s'agit d'une simple vérification pour voir si on démarre bien le programme en tant qu'administrateur système
** utils/list.c
*** void init_str_list(StrList *self)
Cette fonction est le constructeur de notre objet StrList (il s'agit d'une structure qui correspont à un tableau de string allouer de manière automatique)
Il attribue un emplacement mémoire de base.
*** void append_str_list(StrList *self, const char *str) 
La fonction vérifie tous d'abord si notre liste à assez de place en mémoire, si c'est pas le cas on lui donne plus d'emplacement mémoire
et on ajoute la chaine de carractère donner en paramètre à la fin de la liste
*** StrList split_to_liststr(char *str, const char *del) 
Cette méthode découpe une chaine de carractère selon un délimiteur et met chaque partie dans une liste
*** void free_str_list(StrList *self)
Cette fonction libère la mémoire occupé par une liste
** utils/log.c
*** void log_ids(const char *msg)
Cette fonction écrit dans le syslog
** readrules.c
*** StrList read_rules(const char *filename)
C'est ici que se produit la lecture des règles (données en paramètre par l'utilisateur), le fichier est lu ligne par ligne et 
placer dans une liste de string
** rule.c
*** RuleList parse_rule(StrList rules)
Voilà la fonction qui est responsable de traduire chaque règles en une structure qu'on a simplement nommer \Rule\, qu'on place dans une liste
qu'on a nommé \RuleList\ qui occupe un certains emplacement mémoire; la struct rule contient le protocol, l'addresse de source et de destination, le prot de source et de destination. 
*** bool is_in_context(Rule rule, void *packet, Protocole proto)
    Cette fonction vérifie si le paquet match avec une des règles
*** free_rules(RuleList *lst)
cette fonction libère l'emplacement mémoire pris par les listes de règles
